/*
 * Copyright 2009 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.google.gwt.dom.client;

import java.util.HashSet;
import java.util.Set;

import com.google.common.base.Preconditions;
import com.google.gwt.core.client.JavascriptObjectEquivalent;
import com.google.gwt.core.client.JsArray;
import com.google.gwt.dom.client.EventTarget.Type;
import com.google.gwt.user.client.Window;

import cc.alcina.framework.common.client.logic.reflection.AlcinaTransient;
import cc.alcina.framework.common.client.logic.reflection.reachability.Bean;
import cc.alcina.framework.common.client.logic.reflection.reachability.Bean.PropertySource;
import cc.alcina.framework.common.client.logic.reflection.reachability.Reflected;
import cc.alcina.framework.common.client.reflection.Reflections;
import cc.alcina.framework.common.client.serializer.ReflectiveSerializer;

/**
 * A wrapper around the native dom event. It either dispatches to the jso (via
 * DOMImpl.impl) or uses the cached values. Because of the caching mechanism,
 * serialization is relatively simple
 */
@Bean(PropertySource.FIELDS)
public class NativeEvent implements JavascriptObjectEquivalent {
	/**
	 * The left mouse button.
	 */
	public static final int BUTTON_LEFT = 1;

	/**
	 * The middle mouse button.
	 */
	public static final int BUTTON_MIDDLE = 4;

	/**
	 * The right mouse button.
	 */
	public static final int BUTTON_RIGHT = 2;

	public transient NativeEventJso jso;

	/*
	 * FIXME - reflection - package (the gwt accessors should call through to
	 * this package)
	 */
	public Data data = new Data();

	transient Set<Modifier> modifiers;

	public NativeEvent() {
	}

	public NativeEvent(NativeEventJso jso) {
		Preconditions.checkArgument(jso != null);
		this.jso = jso;
		// to save a roundtrip, send the value the jso will have *if it has no
		// existing value*
		data.jsoId = jso.getLcldId(++jsoCounter);
	}

	public NativeEvent(String windowEventTypeName) {
		Preconditions.checkArgument(windowEventTypeName != null);
		data.populateWrapperDefaults();
		data.type = windowEventTypeName;
		data.eventTarget = new EventTarget();
		data.eventTarget.type = Type.window;
	}

	@Override
	public <T extends JavascriptObjectEquivalent> T cast() {
		// only a few calls from the days of Trident
		throw new UnsupportedOperationException();
	}

	/**
	 * Gets whether the ALT key was depressed when the given event occurred.
	 *
	 * @return <code>true</code> if ALT was depressed when the event occurred
	 */
	public final boolean getAltKey() {
		if (data.altKey == null && jso != null) {
			data.altKey = DOMImpl.impl.eventGetAltKey(jso);
		}
		return data.altKey;
	}

	/**
	 * Gets the mouse buttons that were depressed when the given event occurred.
	 *
	 * @return a bit-field, defined by {@link NativeEvent#BUTTON_LEFT},
	 *         {@link NativeEvent#BUTTON_MIDDLE}, and
	 *         {@link NativeEvent#BUTTON_RIGHT}
	 */
	public final int getButton() {
		if (data.button == null && jso != null) {
			data.button = DOMImpl.impl.eventGetButton(jso);
		}
		return data.button;
	}

	/**
	 * Get an array of touches which have changed since the last touch event.
	 *
	 * @return array of touches which have changed since the last touch event
	 */
	public final JsArray<Touch> getChangedTouches() {
		return DOMImpl.impl.getChangedTouches(jso);
	}

	/**
	 * Gets the Unicode codepoint of the character generated by this key event.
	 *
	 * @return the Unicode codepoint.
	 */
	public final int getCharCode() {
		if (data.charCode == null && jso != null) {
			data.charCode = DOMImpl.impl.eventGetCharCode(jso);
		}
		return data.charCode;
	}

	/**
	 * Gets the mouse x-position within the browser window's client area.
	 *
	 * @return the mouse x-position
	 */
	public final int getClientX() {
		if (data.clientX == null && jso != null) {
			data.clientX = DOMImpl.impl.eventGetClientX(jso);
		}
		return data.clientX;
	}

	/**
	 * Gets the mouse y-position within the browser window's client area.
	 *
	 * @return the mouse y-position
	 */
	public final int getClientY() {
		if (data.clientY == null && jso != null) {
			data.clientY = DOMImpl.impl.eventGetClientY(jso);
		}
		return data.clientY;
	}

	/**
	 * Gets whether the CTRL key was depressed when the given event occurred.
	 *
	 * @return <code>true</code> if CTRL was depressed when the event occurred
	 */
	public final boolean getCtrlKey() {
		if (data.ctrlKey == null && jso != null) {
			data.ctrlKey = DOMImpl.impl.eventGetCtrlKey(jso);
		}
		return data.ctrlKey;
	}

	/**
	 * Gets the current target element of this event. This is the element whose
	 * listener fired last, not the element which fired the event initially.
	 *
	 * @return the event's current target element
	 */
	public final EventTarget getCurrentEventTarget() {
		if (data.currentEventTarget == null && jso != null) {
			data.currentEventTarget = DOMImpl.impl.eventGetCurrentTarget(jso);
		}
		return data.currentEventTarget;
	}

	/**
	 * Get the {@link DataTransfer} associated with the current drag event.
	 *
	 * @return the {@link DataTransfer} object, or null if not a drag event
	 */
	public final native DataTransfer getDataTransfer() /*-{
    return this.dataTransfer || null;
	}-*/;

	/**
	 * Returns the element that was the actual target of the given event.
	 *
	 * @return the target element
	 */
	public final EventTarget getEventTarget() {
		if (data.eventTarget == null && jso != null) {
			data.eventTarget = DOMImpl.impl.eventGetTarget(jso);
		}
		return data.eventTarget;
	}

	/**
	 * Gets the key (code associated with the keyevent key) associated with this
	 * event.
	 *
	 * @return the key
	 */
	public final String getKey() {
		if (data.key == null && jso != null) {
			data.key = jso.getKey();
		}
		return data.key;
	}

	/**
	 * Gets the key code (code associated with the physical key) associated with
	 * this event.
	 *
	 * @return the key code
	 * @see com.google.gwt.event.dom.client.KeyCodes
	 */
	public final int getKeyCode() {
		if (data.keyCode == null && jso != null) {
			data.keyCode = DOMImpl.impl.eventGetKeyCode(jso);
		}
		return data.keyCode;
	}

	/**
	 * Gets whether the META key was depressed when the given event occurred.
	 *
	 * @return <code>true</code> if META was depressed when the event occurred
	 */
	public final boolean getMetaKey() {
		if (data.metaKey == null && jso != null) {
			data.metaKey = DOMImpl.impl.eventGetMetaKey(jso);
		}
		return data.metaKey;
	}

	@AlcinaTransient
	public Set<Modifier> getModifiers() {
		if (modifiers == null) {
			modifiers = new HashSet<>();
			if (getCtrlKey()) {
				modifiers.add(Modifier.CTRL);
			}
			if (getAltKey()) {
				modifiers.add(Modifier.ALT);
			}
			if (getShiftKey()) {
				modifiers.add(Modifier.SHIFT);
			}
			if (getMetaKey()) {
				modifiers.add(Modifier.META);
			}
		}
		return modifiers;
	}

	/**
	 * Gets the velocity of the mouse wheel associated with the event along the
	 * Y axis.
	 * <p>
	 * The velocity of the event is an artificial measurement for relative
	 * comparisons of wheel activity. It is affected by some non-browser
	 * factors, including choice of input hardware and mouse acceleration
	 * settings. The sign of the velocity measurement agrees with the screen
	 * coordinate system; negative values are towards the origin and positive
	 * values are away from the origin. Standard scrolling speed is
	 * approximately ten units per event.
	 * </p>
	 *
	 * @return The velocity of the mouse wheel.
	 */
	public final int getMouseWheelVelocityY() {
		if (data.mouseWheelVelocityY == null && jso != null) {
			data.mouseWheelVelocityY = DOMImpl.impl
					.eventGetMouseWheelVelocityY(jso);
		}
		return data.mouseWheelVelocityY;
	}

	public final NativeBeforeInputEvent getNativeBeforeInputEvent() {
		return new NativeBeforeInputEvent(jso);
	}

	/**
	 * Gets the related target for this event.
	 *
	 * @return the related target
	 */
	public final EventTarget getRelatedEventTarget() {
		if (data.relatedEventTarget == null && jso != null) {
			data.relatedEventTarget = DOMImpl.impl.eventGetRelatedTarget(jso);
		}
		return data.relatedEventTarget;
	}

	/**
	 * Get the rotation in degrees, with positive values indicating clockwise
	 * rotation.
	 *
	 * @return the rotation in degrees since the gesture started
	 */
	public final double getRotation() {
		if (data.rotation == null && jso != null) {
			data.rotation = DOMImpl.impl.eventGetRotation(jso);
		}
		return data.rotation;
	}

	/**
	 * Get the amount scaled since the gesture started, with 1.0 representing no
	 * scaling.
	 *
	 * @return the amount scaled since the gesture started
	 */
	public final double getScale() {
		if (data.scale == null && jso != null) {
			data.scale = DOMImpl.impl.eventGetScale(jso);
		}
		return data.scale;
	}

	/**
	 * Gets the mouse x-position on the user's display.
	 *
	 * @return the mouse x-position
	 */
	public final int getScreenX() {
		if (data.screenX == null && jso != null) {
			data.screenX = DOMImpl.impl.eventGetScreenX(jso);
		}
		return data.screenX;
	}

	/**
	 * Gets the mouse y-position on the user's display.
	 *
	 * @return the mouse y-position
	 */
	public final int getScreenY() {
		if (data.screenY == null && jso != null) {
			data.screenY = DOMImpl.impl.eventGetScreenY(jso);
		}
		return data.screenY;
	}

	/**
	 * Gets whether the shift key was depressed when the given event occurred.
	 *
	 * @return <code>true</code> if shift was depressed when the event occurred
	 */
	public final boolean getShiftKey() {
		if (data.shiftKey == null && jso != null) {
			data.shiftKey = DOMImpl.impl.eventGetShiftKey(jso);
		}
		return data.shiftKey;
	}

	/**
	 * Gets a string representation of this event.
	 *
	 * We do not override {@link #toString()} because it is final in
	 * {@link com.google.gwt.core.client.JavaScriptObject }.
	 *
	 * @return the string representation of this event
	 */
	public final String getString() {
		if (data.string == null && jso != null) {
			data.string = DOMImpl.impl.eventToString(jso);
		}
		return data.string;
	}

	/**
	 * Get an array of touches which have changed since the last touch event.
	 *
	 * @return array of touches which have changed since the last touch event
	 */
	public final JsArray<Touch> getTargetTouches() {
		return DOMImpl.impl.getTargetTouches(jso);
	}

	/**
	 * Get an array of touches which have changed since the last touch event.
	 *
	 * @return array of touches which have changed since the last touch event
	 */
	public final JsArray<Touch> getTouches() {
		return DOMImpl.impl.getTouches(jso);
	}

	/**
	 * Gets the enumerated type of this event.
	 *
	 * @return the event's enumerated type
	 */
	public final String getType() {
		if (data.type == null && jso != null) {
			data.type = DOMImpl.impl.eventGetType(jso);
		}
		return data.type;
	}

	/**
	 * Prevents the browser from taking its default action for the given event.
	 */
	public final void preventDefault() {
		DOMImpl.impl.eventPreventDefault(this);
	}

	/*
	 * returns null if the event cannot be serialized (so should not be emitted)
	 */
	public <NE extends NativeEvent> NE serializableForm() {
		NativeEvent event = Reflections.newInstance(getClass());
		if (jso == null) {
			event.data = data;
		} else {
			event.jso = jso;
			if (!event.serializableForm0()) {
				return null;
			}
			event.data.jsoId = getId();
		}
		return (NE) event;
	}

	/**
	 * return false if the event cannot be serialized (refers to a removed dom
	 * node)
	 */
	boolean serializableForm0() {
		getAltKey();
		getButton();
		getCharCode();
		getClientX();
		getClientY();
		getCurrentEventTarget();
		getEventTarget();
		getKey();
		getKeyCode();
		getMetaKey();
		getMouseWheelVelocityY();
		getRelatedEventTarget();
		getRotation();
		getScale();
		getScreenX();
		getScreenY();
		getShiftKey();
		getCtrlKey();
		getString();
		getType();
		boolean result = data.toSerializableForm();
		jso = null;
		return result;
	}

	/**
	 * Stops the event from being propagated to parent elements.
	 */
	public final void stopPropagation() {
		DOMImpl.impl.eventStopPropagation(this);
	}

	@Override
	public String toString() {
		if (jso != null) {
			return jso.toString();
		}
		if (data.type != null) {
			return data.toString();
		}
		return super.toString();
	}

	static int jsoCounter;

	public int getId() {
		Preconditions.checkState(data.jsoId != 0);
		return data.jsoId;
	}

	@Bean(PropertySource.FIELDS)
	public static class Data {
		int jsoId;

		String type;

		String string;

		Boolean shiftKey;

		Integer screenY;

		Integer screenX;

		Double scale;

		Double rotation;

		EventTarget relatedEventTarget;

		Integer mouseWheelVelocityY;

		Boolean metaKey;

		Integer keyCode;

		EventTarget eventTarget;

		EventTarget currentEventTarget;

		Boolean ctrlKey;

		Integer clientY;

		Integer clientX;

		Integer charCode;

		Integer button;

		Boolean altKey;

		String key;

		boolean toSerializableForm() {
			EventTarget eventTarget = EventTarget
					.serializableForm(this.eventTarget);
			EventTarget relatedEventTarget = EventTarget
					.serializableForm(this.relatedEventTarget);
			EventTarget currentEventTarget = EventTarget
					.serializableForm(this.currentEventTarget);
			if (eventTarget == null && this.eventTarget != null) {
				return false;
			}
			if (relatedEventTarget == null && this.relatedEventTarget != null) {
				return false;
			}
			if (currentEventTarget == null && this.currentEventTarget != null) {
				return false;
			}
			return true;
		}

		void populateWrapperDefaults() {
			shiftKey = false;
			screenY = 0;
			screenX = 0;
			scale = 0.0;
			rotation = 0.0;
			mouseWheelVelocityY = 0;
			metaKey = false;
			keyCode = 0;
			ctrlKey = false;
			clientY = 0;
			clientX = 0;
			charCode = 0;
			button = 0;
			altKey = false;
		}

		@Override
		public String toString() {
			return ReflectiveSerializer.serialize(this);
		}
	}

	@Reflected
	public static enum Modifier {
		META, CTRL, ALT, SHIFT,
		/*
		 * META (osx), CTRL (other) - not emitted by getModifiers, but used as a
		 * matcher
		 */
		OS_MODIFIER;

		public Modifier osDependent() {
			switch (this) {
			case OS_MODIFIER:
				boolean mac = Window.Navigator.getPlatform().matches("Mac.*");
				return mac ? Modifier.META : CTRL;
			default:
				return this;
			}
		}
	}

	public static class NativeBeforeInputEvent {
		private NativeEventJso eventJso;

		NativeBeforeInputEvent(NativeEventJso eventJso) {
			this.eventJso = eventJso;
		}

		public native String getData() /*-{
      return this.@com.google.gwt.dom.client.NativeEvent.NativeBeforeInputEvent::eventJso.data;
		}-*/;

		public native String getDataTransfer() /*-{
      return this.@com.google.gwt.dom.client.NativeEvent.NativeBeforeInputEvent::eventJso.dataTransfer;
		}-*/;

		public native String getInputType() /*-{
      return this.@com.google.gwt.dom.client.NativeEvent.NativeBeforeInputEvent::eventJso.inputType;
		}-*/;

		public native boolean getIsComposing() /*-{
      return this.@com.google.gwt.dom.client.NativeEvent.NativeBeforeInputEvent::eventJso.isComposing;
		}-*/;
	}
}
