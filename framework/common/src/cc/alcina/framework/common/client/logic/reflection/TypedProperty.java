package cc.alcina.framework.common.client.logic.reflection;

import java.util.List;
import java.util.Objects;

import com.totsp.gwittir.client.beans.SourcesPropertyChangeEvents;

import cc.alcina.framework.common.client.reflection.Property;
import cc.alcina.framework.common.client.reflection.Reflections;
import cc.alcina.framework.common.client.util.Ax;
import cc.alcina.framework.common.client.util.NestedName;

/**
 * <p>
 * Note that instances of this should be autogenerated, with the important
 * aspect really being the type of T (the property type)
 * 
 * <p>
 * Because that's defined in generated code, it's not reflectively verified,
 * (and that would be a little tricky since it's the type of the field in the
 * PackageProperties container)
 */
public class TypedProperty<S extends SourcesPropertyChangeEvents, T>
		implements PropertyEnum {
	public static int indexOf(List<TypedProperty> properties, String name) {
		TypedProperty match = properties.stream()
				.filter(p -> Objects.equals(p.name, name)).findFirst()
				.orElse(null);
		return match == null ? -1 : properties.indexOf(match);
	}

	public Class<?> definingType;

	/*
	 * A marker interface for generated classes containing typed properties
	 */
	public interface Container {
	}

	String name;

	public TypedProperty(Class<S> definingType, String name) {
		this.definingType = definingType;
		this.name = name;
	}

	@Override
	public String name() {
		return name;
	}

	/**
	 * The point of the exercise - typed setters! Which fire
	 * propertyChangeEvents!
	 * 
	 * @param propertySource
	 * @param value
	 */
	public void set(S propertySource, T newValue) {
		propertySource.set(name, newValue);
	}

	public T get(S propertySource) {
		return (T) getProperty().get(propertySource);
	}

	Property getProperty() {
		return Reflections.at(definingType).property(name);
	}

	@Override
	public String toString() {
		return Ax.format("%s.%s", NestedName.get(definingType), name);
	}

	/**
	 * 
	 * @param propertySource
	 * @param newValue
	 * @return true if the setter files (!Objects.equals(newValue,oldValue))
	 */
	public boolean setIfNotEqual(S propertySource, T newValue) {
		T existing = get(propertySource);
		if (Objects.equals(existing, newValue)) {
			return false;
		} else {
			set(propertySource, newValue);
			return true;
		}
	}

	public void setIfNotNull(S propertySource, T newValue) {
		T existing = get(propertySource);
		if (existing != null) {
			return;
		} else {
			set(propertySource, newValue);
		}
	}

	public InstanceProperty<S, T> instance(S source) {
		return new InstanceProperty<>(source, this);
	}
}