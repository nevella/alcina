package com.google.gwt.dom.client;

import com.google.gwt.core.client.JavaScriptObject;

public abstract class NodeJso extends JavaScriptObject
		implements ClientDomNode {
	/**
	 * Assert that the given {@link JavaScriptObject} is a DOM node and
	 * automatically typecast it.
	 */
	public static Node as(JavaScriptObject o) {
		assert is(o);
		return nodeFor(o);
	}

	/**
	 * Determines whether the given {@link JavaScriptObject} is a DOM node. A
	 * <code>null</code> object will cause this method to return
	 * <code>false</code>. The try catch is needed for the firefox permission
	 * error: "Permission denied to access property 'nodeType'"
	 */
	public static native boolean is(JavaScriptObject o) /*-{
    try {
      return (!!o) && (!!o.nodeType);
    } catch (e) {
      return false;
    }
	}-*/;

	static <N extends Node> N nodeFor(JavaScriptObject o) {
		return LocalDom.nodeFor(o);
	}

	protected NodeJso() {
	}

	@Override
	public final <T extends Node> T appendChild(T newChild) {
		if (LocalDom.isPending(this)) {
			return null;
		}
		NodeJso toAppend = resolvedOrPending(newChild);
		return (T) nodeFor(appendChild0(toAppend));
	}

	/**
	 * Adds the node newChild to the end of the list of children of this node.
	 * If the newChild is already in the tree, it is first removed.
	 *
	 * @param newChild
	 *            The node to add
	 * @return The node added
	 */
	final native NodeJso appendChild0(NodeJso newChild) /*-{
    @com.google.gwt.dom.client.LocalDom::verifyMutatingState();
    return this.appendChild(newChild);
	}-*/;

	@Override
	public final native void callMethod(String methodName) /*-{
    this[methodName]();
	}-*/;

	@Override
	public final Node cloneNode(boolean deep) {
		return nodeFor(cloneNode0(deep));
	}

	/**
	 * Returns a duplicate of this node, i.e., serves as a generic copy
	 * constructor for nodes. The duplicate node has no parent; (parentNode is
	 * null.).
	 *
	 * Cloning an Element copies all attributes and their values, including
	 * those generated by the XML processor to represent defaulted attributes,
	 * but this method does not copy any text it contains unless it is a deep
	 * clone, since the text is contained in a child Text node. Cloning an
	 * Attribute directly, as opposed to be cloned as part of an Element cloning
	 * operation, returns a specified attribute (specified is true). Cloning any
	 * other type of node simply returns a copy of this node.
	 *
	 * @param deep
	 *            If true, recursively clone the subtree under the specified
	 *            node; if false, clone only the node itself (and its
	 *            attributes, if it is an {@link Element})
	 * @return The duplicate node
	 */
	final native NodeJso cloneNode0(boolean deep) /*-{
    @com.google.gwt.dom.client.LocalDom::verifyMutatingState();
    return this.cloneNode(deep);
	}-*/;

	@Override
	public final Node getChild(int index) {
		return ClientDomNodeStatic.getChild(this, index);
	}

	@Override
	public final int getChildCount() {
		return ClientDomNodeStatic.getChildCount(this);
	}

	/**
	 * A NodeList that contains all children of this node. If there are no
	 * children, this is a NodeList containing no nodes.
	 */
	@Override
	public final NodeList<Node> getChildNodes() {
		return new NodeList<>(getChildNodes0());
	}

	final native NodeListJso<Node> getChildNodes0() /*-{
    return this.childNodes;
	}-*/;

	@Override
	public final Node getFirstChild() {
		return nodeFor(getFirstChild0());
	}

	/**
	 * The first child of this node. If there is no such node, this returns
	 * null.
	 */
	public final native NodeJso getFirstChild0() /*-{
    return this.firstChild;
	}-*/;

	@Override
	public final Node getLastChild() {
		return nodeFor(getLastChild0());
	}

	/**
	 * The last child of this node. If there is no such node, this returns null.
	 */
	private final native NodeJso getLastChild0() /*-{
    return this.lastChild;
	}-*/;

	@Override
	public final Node getNextSibling() {
		return nodeFor(getNextSibling0());
	}

	/**
	 * The node immediately following this node. If there is no such node, this
	 * returns null.
	 */
	private final native NodeJso getNextSibling0() /*-{
    return this.nextSibling;
	}-*/;

	/**
	 * The name of this node, depending on its type; see the table above.
	 */
	@Override
	public final native String getNodeName() /*-{
    return this.nodeName;
	}-*/;

	/**
	 * A code representing the type of the underlying object, as defined above.
	 */
	@Override
	public final native short getNodeType() /*-{
    return this.nodeType;
	}-*/;

	/**
	 * The value of this node, depending on its type; see the table above. When
	 * it is defined to be null, setting it has no effect.
	 */
	@Override
	public final native String getNodeValue() /*-{
    return this.nodeValue;
	}-*/;

	@Override
	public final Document getOwnerDocument() {
		return nodeFor(getOwnerDocument0());
	}

	/**
	 * The Document object associated with this node. This is also the
	 * {@link Document} object used to create new nodes.
	 */
	private final native DocumentJso getOwnerDocument0() /*-{
    return this.ownerDocument;
	}-*/;

	@Override
	public final Element getParentElement() {
		return nodeFor(getParentElementJso());
	}

	final native ElementJso getParentElementJso() /*-{
    var parentElement = this.parentElement;
    if (parentElement) {
      return parentElement;
    }
    var parentNode = this.parentNode;
    if (parentNode && parentNode.nodeType == 1) {
      return parentNode;
    } else {
      return null;
    }
	}-*/;

	@Override
	public final Node getParentNode() {
		return nodeFor(getParentNodeJso());
	}

	/**
	 * The parent of this node. All nodes except Document may have a parent.
	 * However, if a node has just been created and not yet added to the tree,
	 * or if it has been removed from the tree, this is null.
	 */
	public final native NodeJso getParentNodeJso() /*-{
    return this.parentNode;
	}-*/;

	@Override
	public final Node getPreviousSibling() {
		return nodeFor(getPreviousSibling0());
	}

	/**
	 * The node immediately preceding this node. If there is no such node, this
	 * returns null.
	 */
	private final native NodeJso getPreviousSibling0() /*-{
    return this.previousSibling;
	}-*/;

	/**
	 * Returns whether this node has any children.
	 */
	@Override
	public final native boolean hasChildNodes() /*-{
    return this.hasChildNodes();
	}-*/;

	@Override
	public final boolean hasParentElement() {
		return ClientDomNodeStatic.hasParentElement(this);
	}

	@Override
	public final native int indexInParentChildren() /*-{
    var idx = 0;
    var size = this.parentNode.childNodes.length;
    for (; idx < size; idx++) {
      var node = this.parentNode.childNodes.item(idx);
      if (node == this) {
        return idx;
      }
    }
    return -1;
	}-*/;

	@Override
	public final Node insertAfter(Node newChild, Node refChild) {
		throw new UnsupportedOperationException();
	}

	@Override
	public final Node insertBefore(Node newChild, Node refChild) {
		if (LocalDom.isPending(this)) {
			return null;
		}
		NodeJso newChildDom = resolvedOrPending(newChild);
		NodeJso refChildDom = resolvedOrPending(refChild);
		return nodeFor(insertBefore0(newChildDom, refChildDom));
	}

	/**
	 * Inserts the node newChild before the existing child node refChild. If
	 * refChild is <code>null</code>, insert newChild at the end of the list of
	 * children.
	 *
	 * @param newChild
	 *            The node to insert
	 * @param refChild
	 *            The reference node (that is, the node before which the new
	 *            node must be inserted), or <code>null</code>
	 * @return The node being inserted
	 */
	final native NodeJso insertBefore0(NodeJso newChild, NodeJso refChild) /*-{
    @com.google.gwt.dom.client.LocalDom::verifyMutatingState();
    return this.insertBefore(newChild, refChild);
	}-*/;

	@Override
	public final Node insertFirst(Node child) {
		throw new UnsupportedOperationException();
	}

	@Override
	public final boolean isJso() {
		return true;
	}

	/**
	 * Determine whether a node is equal to, or the child of, this node.
	 *
	 * @param child
	 *            the potential child element
	 * @return <code>true</code> if the relationship holds
	 */
	@Override
	public final boolean isOrHasChild(Node child) {
		assert (child != null) : "Child cannot be null";
		return DOMImpl.impl.isOrHasChild(node(), child);
	}

	@Override
	public final Node node() {
		return LocalDom.nodeFor(this);
	}

	@Override
	public final void preRemove(Node node) {
	}

	final boolean provideIsElement() {
		return getNodeType() == Node.ELEMENT_NODE;
	}

	public final boolean provideIsNonStructural() {
		return getNodeType() == Node.TEXT_NODE
				|| getNodeType() == Node.COMMENT_NODE;
	}

	@Override
	public final Node removeAllChildren() {
		return ClientDomNodeStatic.removeAllChildren(this);
	}

	@Override
	public final Node removeChild(Node oldChild) {
		// removed node should never be used - so can optimise as follows
		if (oldChild.linkedToRemote()) {
			removeChild0(oldChild.remote());
		}
		return null;
		// NodeJso resolvedOrPending = resolvedOrPending(oldChild);
		// if (resolvedOrPending.getParentNode() == null) {
		// return nodeFor(resolvedOrPending);
		// } else {
		// return nodeFor(removeChild0(resolvedOrPending));
		// }
	}

	/**
	 * Removes the child node indicated by oldChild from the list of children,
	 * and returns it.
	 *
	 * @param oldChild
	 *            The node being removed
	 * @return The node removed
	 */
	private final native NodeJso removeChild0(NodeJso oldChild) /*-{
    @com.google.gwt.dom.client.LocalDom::verifyMutatingState();
    //3 == TEXT_NODE
    if (oldChild.parentNode == null && oldChild.nodeType == 3) {
      //handle strange IE11 case (text node equality/substitution?)
      var children = this.childNodes;
      for (var i = 0; i < children.length; i++) {
        var node = children[i];
        if (node.nodeType == 3 && node.data == oldChild.data) {
          this.removeChild(node);
          return oldChild;
        }
      }
      //not matched, fall through (which will throw a DOMException)
    }
    return this.removeChild(oldChild);
	}-*/;

	@Override
	public final void removeFromParent() {
		ClientDomNodeStatic.removeFromParent(this);
	}

	@Override
	public final Node replaceChild(Node newChild, Node oldChild) {
		NodeJso newChildDom = resolvedOrPending(newChild);
		NodeJso oldChildDom = resolvedOrPending(oldChild);
		return nodeFor(replaceChild0(newChildDom, oldChildDom));
	}

	/**
	 * Replaces the child node oldChild with newChild in the list of children,
	 * and returns the oldChild node.
	 *
	 * @param newChild
	 *            The new node to put in the child list
	 * @param oldChild
	 *            The node being replaced in the list
	 * @return The node replaced
	 */
	private final native NodeJso replaceChild0(NodeJso newChild,
			NodeJso oldChild) /*-{
    @com.google.gwt.dom.client.LocalDom::verifyMutatingState();
    return this.replaceChild(newChild, oldChild);
	}-*/;

	/**
	 * Link remote to [remote or local]
	 */
	private NodeJso resolvedOrPending(Node node) {
		if (node == null) {
			return null;
		}
		if (node.linkedToRemote()) {
			return node.remote();
		} else {
			if (node.wasSynced()) {
				LocalDom.ensureRemote(node);
				return node.remote();
			} else {
				return LocalDom.ensureRemoteNodeMaybePendingSync(node);
			}
		}
	}

	/**
	 * The value of this node, depending on its type; see the table above. When
	 * it is defined to be null, setting it has no effect.
	 */
	@Override
	public final native void setNodeValue(String nodeValue) /*-{
    @com.google.gwt.dom.client.LocalDom::verifyMutatingState();
    this.nodeValue = nodeValue;
	}-*/;
}
